Steps:
0. Debug cycle counter?  Could put on board.
1. Pipelining
2. Allow for arbitrary-time memory access / stalls
3. Switch to mix of BRAM & DDR
4. Move to design with unified memory, instruction/data caches, memory controller

Stages:
- IF (Fetch instruction)
    - Finish cleaning up stage_valid vs. stall
    - Does it still work if memory inputs are latched?
    - Test with a simulated BRAM w/ latched input and outputs
- ID (Decode instruction and read registers)
- EX (Execute instruction (ALU))
- MA (Memory access)
- WB (Register commit)

Hazards:
- Structural - Hardware resources used by multiple stages.  Avoid this by not sharing resources across stages.
- Data       - Instruction needs reg or mem value being modified by later instruction
- Control    - Earlier stages may need to be flushed if a branch occurs, as it is the wrong instruction in-flight

Structural hazard avoidance:
- Ensure all hardware used by only one stage.  Duplciate if necessary.

Data hazard avoidance:
- MA and WB advertise the pending register values; EX consumes them if needed.

Control hazard avoidance:
- EX advertises branch addresses; ID & IF notice and flush
- Therefore, stages advertise if they are empty/stalled so subsequent stages can also stall

Reference:
https://passlab.github.io/CSE564/notes/lecture09_RISCV_Impl_pipeline.pdf
https://github.com/ultraembedded/riscv/
https://github.com/combinatorylogic/soc/blob/master/backends/c2/hw/rtl/core.v

Video signals?
Keyboard/mouse signals?
USB signals?
Pipelining?
Switch from distributed memory to BRAM or DDR?
